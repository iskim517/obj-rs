var searchIndex = {};
searchIndex['obj'] = {"items":[[0,"","obj","[Wavefront OBJ][obj] parser for Rust. It handles both `.obj` and `.mtl` formats. [GitHub][]"],[3,"Obj","","3D model object loaded from wavefront OBJ."],[12,"name","","Object's name.",0],[12,"vertices","","Vertex buffer.",0],[12,"indices","","Index buffer.",0],[3,"Vertex","","Vertex data type of `Obj` which contains position and normal data of a vertex."],[12,"position","","Position vector of a vertex.",1],[12,"normal","","Normal vertor of a vertex.",1],[3,"Position","","Vertex data type of `Obj` which contains only position data of a vertex."],[12,"position","","Position vector of a vertex.",2],[5,"load_obj","","Load a wavefront OBJ file into Rust & OpenGL friendly format."],[0,"raw","","Provides low-level API for Wavefront OBJ format."],[0,"object","obj::raw","Parses `.obj` format which stores 3D mesh data"],[3,"RawObj","obj::raw::object","Low-level Rust binding for `.obj` format."],[12,"name","","Name of the object.",3],[12,"material_libraries","","`.mtl` files which required by this object.",3],[12,"positions","","Position vectors of each vertex.",3],[12,"tex_coords","","Texture coordinates of each vertex.",3],[12,"normals","","Normal vectors of each vertex.",3],[12,"param_vertices","","Parametric vertices.",3],[12,"points","","Points which stores the index data of position vectors.",3],[12,"lines","","Lines which store the index data of vectors.",3],[12,"polygons","","Polygons which store the index data of vectors.",3],[12,"groups","","Groups of multiple geometries.",3],[12,"meshes","","Geometries which consist in a same material.",3],[12,"smoothing_groups","","Smoothing groups.",3],[12,"merging_groups","","Merging groups.",3],[3,"Group","","A group which contains ranges of points, lines and polygons"],[12,"points","","Multiple range of points",4],[12,"lines","","Multiple range of lines",4],[12,"polygons","","Multiple range of polygons",4],[3,"Range","","A struct which represent `[start, end)` range."],[12,"start","","The lower bound of the range (inclusive).",5],[12,"end","","The upper bound of the range (exclusive).",5],[4,"Line","","The `Line` type."],[13,"P","","A line which contains only the position data of both ends",6],[13,"PT","","A line which contains both position and texture coordinate data of both ends",6],[4,"Polygon","","The `Polygon` type."],[13,"P","","A polygon which contains only the position data of each vertex.",7],[13,"PT","","A polygon which contains both position and texture coordinate data of each vertex.",7],[13,"PN","","A polygon which contains both position and normal data of each vertex.",7],[13,"PTN","","A polygon which contains all position, texture coordinate and normal data of each vertex.",7],[5,"parse_obj","","Parses a wavefront `.obj` format."],[6,"Point","","The `Point` type which stores the index of the position vector."],[11,"fmt","","",6],[11,"clone","","",6],[11,"eq","","",6],[11,"ne","","",6],[11,"fmt","","",7],[11,"clone","","",7],[11,"eq","","",7],[11,"ne","","",7],[11,"fmt","","",4],[11,"clone","","",4],[11,"fmt","","",5],[11,"clone","","",5],[11,"eq","","",5],[11,"ne","","",5],[0,"material","obj::raw","Parses `.mtl` format which stores material data"],[3,"RawMtl","obj::raw::material","Low-level Rust binding for `.mtl` format *(incomplete)*."],[5,"parse_mtl","","Parses a wavefront `.mtl` format *(incomplete)*"],[6,"ObjResult","obj","A type for results generated by `load_obj` and `load_mtl` where the `Err` type is hard-wired to\n`ObjError`"],[8,"FromRawVertex","","Conversion from `RawObj`'s raw data."],[10,"process","","Build vertex and index buffer from raw object data.",8],[11,"fmt","","",1],[11,"clone","","",1],[11,"eq","","",1],[11,"ne","","",1],[11,"process","","",1],[11,"fmt","","",2],[11,"clone","","",2],[11,"eq","","",2],[11,"ne","","",2],[11,"process","","",2]],"paths":[[3,"Obj"],[3,"Vertex"],[3,"Position"],[3,"RawObj"],[3,"Group"],[3,"Range"],[4,"Line"],[4,"Polygon"],[8,"FromRawVertex"]]};
initSearch(searchIndex);
